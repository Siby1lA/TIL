# Redux

리덕스를 사용하면 컴포넌트들의 상태 관련 로직들을 파일들로 분리시켜 더욱 효율적으로 관리 가능하며 글로벌 상태 관리도 손쉽다.
Context API, useReducer을 사용해서 개발하는 흐름을 리덕스를 사용하는 것과 매우 유사하다.

리덕스는 Context API 가 지금의 형태로 사용방식이 개선되기도 전에, 그리고 useReducer라는 Hook이 존재하기 전 부터 만들어진 라이브러리이다.

# 그러면 리덕스와 Context API의 차이는?

## 미들웨어

리덕스로 상태 관리 할 때는 useReducer의 개념인 리듀서 함수를 사용한다. 리덕스의 미들웨어를 사용하면 액션 객체가 리듀서에 처리되기 전에 우리가 원하는 작업들을 수행 할 수 있다.

- 특정 조건에 따라 액션 무시
- 액션을 콘솔에 출력하거나 서버쪽에 로깅
- 액션이 디스패치 됐을 때 이를 수정해 리듀서에게 전달
- 특정 액션이 발생했을 때 이에 기반해 다른 액션 발생
- 특정 액션이 발생했을 때 특정 자바스크립트 함수 실행
  미들웨어는 주로 비동기 작업을 처리 할 때 많이 사용한다.

리덕스 언제 쓸까?

- 프로젝트의 규모가 클때
- 비동자 작업을 자주 할 때
- 리덕스를 배워보니 사용하는게 편할 때

# 리덕스 키워드

## Action

상태에 어떠한 변화가 필요할때 우리는 액션이라는걸 발생시킨다. 이는 하나의 객체로 표현된다.

```
{
  type: "TOGGLE_VALUE"
}
```

액션 객체는 `type` 필드를 필수로 가져야한다. 그 외의 값은 개발자 마음이다.

ex :

```
{
  type: "ADD_TODO",
  data: {
    id: 0,
    text: "리덕스 배우기"
  }
}
```

```
{
  type: "CHANGE_INPUT",
  text: "안녕하세요"
}
```

## 액션 생성함수 (Action Creator)

단순히 파라미터를 받아와 액션 객체 형태로 만들어준다.

```
xport function addTodo(data) {
  return {
    type: "ADD_TODO",
    data
  };
}

// 화살표 함수로도 만들 수 있습니다.
export const changeInput = text => ({
  type: "CHANGE_INPUT",
  text
});
```

이러한 액션 생성함수를 만들어 사용하는 이유는 나중에 컴포넌트에서 더욱 쉽게 액션을 발생시키기 위함이다. 그래서 보통 함수 앞에 `export` 키워드를 붙여 다른 파일에서 불러와서 사용한다.

하지만 리덕스를 사용할 때 생성함수를 사용하는게 필수적이진 않다. 액션을 발생 시킬 때마다 직접 액션 객체를 작성해도 된다.

## Reducer

리듀서는 변화를 일으키는 함수다.
리듀서는 두가지의 파라미터를 받아온다.

```
function reducer(state, action){
  // 상태 업데이트 로직
  return alteredState;
}
```

리듀서는, 현재상태와 전달받은 액션을 참고해 새로운 상태를 만들어 반환한다. `useReducer`와 똑같은 형태이다.

```
function counter(state, action) {
  switch (action.type) {
    case 'INCREASE':
      return state + 1;
    case 'DECREASE':
      return state - 1;
    default:
      return state;
  }
}
```

`useReducer`에서는 일반적으로 `default:` 부분에 `throw new Error('Unhandled Action')`과 같이 에러를 발생시키도록 처리하는게 일반적인데 리덕스의 리듀서에서는 기존의 `state`를 그대로 반환하도록 작성해야한다.

여러개의 리듀서를 만들고 이를 합쳐서 루트 리듀서를 만들 수 있다. 루트 리듀서 안의 작은 리듀서들은 서브 리듀서라고 부른다.

## Store

리덕스에선 한 앱당 하나의 스토어를 만들게 된다.
스토어 안에는 현재 앱 상태, 리듀서가 있고 추가적으로 몇가지의 내장 함수가 있다.

## dispatch

스토어의 내장함수 중 하나 디스패치는 액션을 발생 시킨다.
액션을 파라미터로 전달한다 dispatch(action)

## subscribe

스토어의 내장함수 중 하나 subscribe는 함수 형태의 값을 파라미터로 받아온다. subscribe 함수에 특정 함수를 전달해주면 액션이 디스패치 되었을 때 마다 전달해준 함수가 호출됩니다.

보통 리액트에서 리덕스를 사용할 땐 별로 사용하지 않는다.
그 대신 `connect()`, `useSelector`를 사용해 리덕스 스토어의 상태에 구독한다.

# 리덕스의 3가지 규칙

1. 하나의 앱에는 하나의 스토어를 가져야 한다.

   여러개의 스토어는 가능하나 권장하지 않음
   여러개의 스토어를 사용하면 개발 도구를 활용할 수 없다.

2. 상태는 읽기전용

   state를 업데이트 할 때 직접 push하지 않거나 concat 같은 함수를 사용해 새로운 배열을 만들어 교체하는 방식인데 리덕스도 마찬가지이다.
   이러한 방식은 나중에 개발자 도구를 통해 뒤로 돌릴 수도 있고 다시 앞으로 돌릴 수도 있다.
   리덕스에서 불변성을 유지해야하는 이유는 내부 데이터가 변경 되는 걸 감지하기 위해 shallow equality 라는 검사를 한다. 이를 통해 객체 변화를 감지 할 때 깊숙하게 비교하지 않고 겉핥기 식으로 비교해 좋은 성능을 유지 가능하다.

3. 변화를 일으키는 함수, 리듀서는 선수한 함수여야 한다.
   리듀서는 이전 상태와, 액션 객체를 파라미터로 받는다.
   이전의 상태는 절대로 안건들고 변화를 일으킨 새 상태를 만들어 반환한다.
   똑같은 파라미터로 호출된 리듀서는 언제나 똑같은 결과값을 반환해야만 한다.(순수)

위의 상황에 주의해야 한다. 동일한 인풋이라면 언제나 동일한 아웃풋이어야 한다. 하지만 new Date()나 랜덤 숫자를 생성한다던지.. 네트워크에 요청한다던지 이런 순수하지 않은 작업들은 리듀서 함수 밖에서 처리해야 한다. 이런 처리를 하기 위해 `리덕스 미들웨어`를 사용하곤 한다.

[블로그 정리 추가](https://velog.io/@psb7391/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%A6%AC%EB%8D%95%EC%8A%A4-%EC%A0%95%EB%A6%AC/)
